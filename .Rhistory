seismic_3D +
(1|array),
family = "binomial",
data = wtd_dets)
summary(seismic_3D)
harvest<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
harvest +
(1|array),
family = "binomial",
data = wtd_dets)
summary(harvest)
pipeline<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
pipeline +
(1|array),
family = "binomial",
data = wtd_dets)
summary(pipeline)
ms<-model.sel(disturbance_index, roads, well_gas, well_oil, well_bitumen, inactive_well, harvest, pipeline, seismic, seismic_3D,
rank = "AICc")
ms<- as.data.frame(ms) %>%
# Add model names as a column
mutate(model = rownames(ms)) %>%
# Keep only the columns you care about
dplyr::select(model, df, logLik, AICc, delta, weight) %>%
# Optional: arrange by AICc
arrange(AICc)%>%
mutate(weight = round(weight, digits = 2))
View(ms)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_min_temp_spatial*well_gas+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
summary(well_gas)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_min_temp_spatial*well_gas+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_min_temp_spatial*well_gas+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
lowQ  <- quantile(wtd_dets$well_gas, 0.10, na.rm = TRUE)
highQ <- quantile(wtd_dets$well_gas, 0.90, na.rm = TRUE)
pred_spatial <- ggpredict(
m1,
terms = c("mean_min_temp_spatial [all]",
paste0("well_gas [", round(lowQ, 2), ",", round(highQ, 2), "]")),
type = "fe"
)%>%
rename(mean_min_temp = x,
disturbance_quantile = group)
ggplot(pred_spatial, aes(x = mean_min_temp, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "mean min temp",
y = "deer"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
theme_classic(base_size = 14)
View(pred_spatial)
ggpredict(
m1,
terms = c("mean_min_temp_spatial [all]",
paste0("well_gas [", round(lowQ, 2), ",", round(highQ, 2), "]")),
type = "fe"
)
pred_spatial <- ggpredict(
m1,
terms = c("mean_min_temp_spatial [all]",
"well_gas [all]"),
type = "fe"
)%>%
rename(mean_min_temp = x,
disturbance_quantile = group)
lowQ  <- quantile(wtd_dets$well_gas, 0.10, na.rm = TRUE)
highQ <- quantile(wtd_dets$well_gas, 0.90, na.rm = TRUE)
hist(wtd_dets$well_gas)
min(well_gas)
min(wtd_dets$well_gas)
max(wtd_dets$well_gas)
quantile(wtd_dets$well_gas)
summary(m1)
log(wtd_dets$well_gas)
lowQ  <- min(wtd_dets$well_gas)
highQ <- max(wtd_dets$well_gas)
pred_spatial <- ggpredict(
m1,
terms = c("mean_min_temp_spatial [all]",
"well_gas [lowQ, highQ]"),
type = "fe"
)%>%
rename(mean_min_temp = x,
disturbance_quantile = group)
ggplot(pred_spatial, aes(x = mean_min_temp, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "mean min temp",
y = "deer"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
theme_classic(base_size = 14)
hist(covs$well_gas)
hist(covs$disturbance_index)
hist(wtd_dets$disturbance_index)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_min_temp_spatial*disturbance_index+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_snow_spatial*well_gas+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
lowQ  <- min(wtd_dets$well_gas)
highQ <- max(wtd_dets$well_gas)
pred_spatial <- ggpredict(
m1,
terms = c("mean_snow_spatial [all]",
"well_gas [lowQ, highQ]"),
type = "fe"
)%>%
rename(mean_snow_spatial= x,
disturbance_quantile = group)
ggplot(pred_spatial, aes(x = mean_snow_spatial, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "mean min temp",
y = "deer"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
theme_classic(base_size = 14)
ggplot(pred_spatial, aes(x = mean_snow_spatial, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "mean snow",
y = "deer"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
theme_classic(base_size = 14)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_snow_spatial*well_gas+ lat+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_snow_spatial*well_gas+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
##############################################
#3D seismic has the best predictive effect...but its negative. Strange
#Is there anything that can be done to moderate this?
m1<-glmmTMB::glmmTMB(cbind(deer_present, (n_weeks - deer_present)) ~
mean_snow_spatial*well_gas+ lat + broadleaf+
(1|array),
family = "binomial",
data = wtd_dets)
summary(m1)
lowQ  <- min(wtd_dets$well_gas)
highQ <- max(wtd_dets$well_gas)
pred_spatial <- ggpredict(
m1,
terms = c("mean_snow_spatial [all]",
"well_gas [lowQ, highQ]"),
type = "fe"
)%>%
rename(mean_snow_spatial= x,
disturbance_quantile = group)
ggplot(pred_spatial, aes(x = mean_snow_spatial, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "mean snow",
y = "deer"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low disturbance", "High disturbance")) +
theme_classic(base_size = 14)
ggplot(pred_spatial, aes(x = mean_snow_spatial, y = predicted, colour = disturbance_quantile)) +
geom_line(size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = disturbance_quantile),
alpha = 0.15, colour = NA) +
labs(x = "Scaled average long term snow load @ site",
y = "Probability of deer weekly presence"
) +
scale_colour_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low gas wells", "High gas wells")) +
scale_fill_manual(values = c("#0072B2", "#D55E00"),
labels = c("Low gas wells", "High gas wells")) +
theme_classic(base_size = 14)
# Chunk 1
#Clear everything out and start fresh
rm(list=ls())
library(reproducible) #setting up directories for data management
library(readr)        #Needed to read and merge all the csv's in the camera folder
library(dplyr)        #data wranglin'
library(lubridate)    #datetime manipulation
library(tidyr)        #more data manipulation
library(stringr)      #detecting character strings
library(ggplot2)      #data visualization
library(purrr)        #feline-friendly loops
library(corrplot)     #correlation tests
#This just sets up files for inputs (already created, must contain your files), and outputs
input_directory<-reproducible::checkPath(file.path(getwd(), "inputs"), create = TRUE)
output_directory<-reproducible::checkPath(file.path(getwd(), "outputs"), create = TRUE)
figure_directory<-reproducible::checkPath(file.path(getwd(), "figures"), create = TRUE)
#read in the files we need
dets<-read.csv(file.path(input_directory, "OSM_camera_detections.csv"))
camop<-read.csv(file.path(input_directory, "OSM_camera_deployment.csv"))
covs<-read.csv(file.path(input_directory, "OSM_camera_covariates.csv"))
#And the weather data
weather<-read.csv(file.path(input_directory, "daymet_weather_data.csv"))
weather_10<-read.csv(file.path(input_directory, "daymet_weather_data_10year.csv"))
# Chunk 2
#First, I want to know when deer were detected, this is going to influence when and where we look for deer
wtd<-dets%>%
filter(species == "White-tailed deer")%>%
#Just ensuring its read in as a datetime here!
mutate(datetime = ymd_hms(datetime))
#arrange the detection by site, species, and time, then group by site
wtd<-wtd%>%
arrange(array, site, datetime)%>%
group_by(site)%>%
#Create a lag time that will be used to calculate time differences
mutate(duration = as.numeric(difftime(datetime,lag(datetime),units = "mins")))
#Set up the framework for assigning unique IDs
wtd$Event.ID<-9999 #This is just an arbitrary event identification code
mins<-2 # THIS IS THE DETECTION EVENT BREAK-POINT YOU CAN CHANGE
seq <- as.numeric(paste0(nrow(wtd),0))
seq <- round(seq,-(nchar(seq)))
#This will go through each row and figure out how far apart in time each one is
#So this creates unique event identifications for subsequent rows IF they are more than 30mins apart
for (i in 2:nrow(wtd)) {
wtd$Event.ID[i-1]  <- paste0("E",format(seq, scientific = F))
if(is.na(wtd$duration[i]) | abs(wtd$duration[i]) > mins){
seq <- seq + 1
}
}
# Update the information for the last row
# group ID  for the last row
if(wtd$duration[nrow(wtd)] < mins|
is.na(wtd$duration[nrow(wtd)])){
wtd$Event.ID[nrow(wtd)] <- wtd$Event.ID[nrow(wtd)-1]
} else{
wtd$Event.ID[nrow(wtd)] <- paste0("E",format(seq+1, scientific = F))
}
#Lets reduce this down to the information we want (too many columns to bring along!)
wtd<-wtd%>%
dplyr::select(array, site, datetime, Event.ID)
#And I think at this point, just take the first observation for each event ID
wtd<-wtd%>%
group_by(Event.ID)%>%
slice(1)
# Chunk 3
#How many ind detections
nrow(wtd)
#How many sites?
n_distinct(wtd$site)
#Site occupancy?
n_distinct(wtd$site)/n_distinct(dets$site)
#What do detections look like throughout the year?
#Ok so based on this, a good way to look at young deer would be from June to September each year!
wtd%>%
mutate(month = month(datetime))%>%
group_by(month)%>%
summarise(n_obs = n())%>%
ggplot(aes(x = as.factor(month), y = n_obs))+
geom_bar(stat = "identity")+
ylab("Independent Detections")+
ggtitle("Detections of deer ~ month of year")
# Chunk 4
#Lets first work on operability of cameras. We will first use the main detection frame as this has all the days of operation for all sites.
#Filter down to june, july, august, and september of each year
df<-dets%>%
mutate(month = month(datetime),
date = date(datetime))%>%
filter(month %in% 6:9)
#Keep only unique dates for each array/site
df<-df%>%
distinct(array, site, date)
#Identify the year and week for each site, and only keep sites that had full weeks
weekly_operation<-df%>%
mutate(year = year(date),
week = week(date))%>%
#Have to group by year as well, since some sites ran across several years
group_by(array, year, site, week)%>%
summarise(n_days = n_distinct(date))%>%
#Here we remove sites that didn't have full weeks
filter(n_days == 7)
#How many sites is this? Nice nice nice
n_distinct(weekly_operation$site)
#How many weeks per site?
weekly_operation%>%
group_by(year, site)%>%
summarise(n_weeks = n_distinct(week))%>%
summarise(mean_weeks = mean(n_weeks),
sd_weeks = sd(n_weeks),
min_weeks = min(n_weeks),
max_weeks = max(n_weeks))
####################################################################################
#Now that we have a list of cameras with operation we can use, I need to identify how many detentions of each group, for each site/year/week combination
#Lets create a temporary frame to work in so we don't have to re-run the independent detection loop again if needed
wtd_dets<-wtd
#First, filter our dataframe to the same months
wtd_dets<-wtd_dets%>%
mutate(month = month(datetime))%>%
filter(month %in% 6:9)
#Add the year and week columns we will need
wtd_dets<-wtd_dets%>%
mutate(year = year(datetime),
week = week(datetime))
#Ok now I think I can do this. Since each event with a yoy or lone female is indicated by just a 1 (presence), I should be able to sum occurrences for each year/site/week combination right?
#REMEMBER - this will not account for double absences! Sites with zero young and zero adult will not be captured here. Address this next
wtd_dets<-wtd_dets%>%
group_by(array, year, site, week)%>%
summarise(n_obs = n())%>%
#And then take those sums, and turn them back into presence/absence again
#Remember just want to know for each week if a group was present!
mutate(across(c(n_obs),
~ ifelse(is.na(.x) | .x == 0, 0, 1)))%>%
#rename for clarity
rename(deer_present = n_obs)
#And now, we can merge this with the weekly operation file.
wtd_dets<-left_join(weekly_operation, wtd_dets, by = c("array", "year", "site", "week"))
#And now, lets fill in the zeros for the weeks where neither a young or adult was detected
wtd_dets<-wtd_dets%>%
mutate(deer_present = ifelse(is.na(deer_present), 0, deer_present))
#Math check, how many weeks?
wtd_dets%>%
group_by(year, site)%>%
summarise(n_weeks = n_distinct(week))%>%
ungroup()%>%
summarise(total_weeks = sum(n_weeks))
#And last step, for each array, site, and year --> how many weeks were sampled, and how many of those weeks had a detection of a young or an adult. Again, since young and adult are coded as present or absent, we can sum them up
wtd_dets<-wtd_dets%>%
group_by(array, year, site)%>%
summarise(n_weeks = n_distinct(week),   #how many weeks for each site
deer_present = sum(deer_present)) #how many of those weeks had an adult
#Can we visualize this nicely? Yes, but need to manipulate the frame a little bit for eas
ggplot(wtd_dets, aes(x = array, y = deer_present / n_weeks))+
geom_jitter()+
ylab("Proportion Summer Weeks Present")+
xlab("Array")+
theme_classic()
covs%>%
filter(buff_dist == 1000)%>%
rename(broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)
covs%>%
filter(buff_dist == 1000)%>%
dplyr::select(array, site,
broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)
covs%>%
filter(buff_dist == 1000)%>%
dplyr::select(array, site,
broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)%>%
mutate(across(c(broadleaf, grassland, coniferous, mixed, shrub)),
.fns = ~ as.numeric(scale(.x))))
covs%>%
filter(buff_dist == 1000)%>%
dplyr::select(array, site,
broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)%>%
mutate(across(c(broadleaf, grassland, coniferous, mixed, shrub)),
.fns = ~ as.numeric(scale(.x)))
covs%>%
filter(buff_dist == 1000)%>%
dplyr::select(array, site,
broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)%>%
mutate(across(c(broadleaf, grassland, coniferous, mixed, shrub),
.fns = ~ as.numeric(scale(.x))))
habitat<-covs%>%
filter(buff_dist == 1000)%>%
dplyr::select(array, site,
broadleaf = lc_class220,
grassland = lc_class110,
coniferous = lc_class210,
mixed = lc_class230,
shrub = lc_class50)%>%
mutate(across(c(broadleaf, grassland, coniferous, mixed, shrub),
.fns = ~ as.numeric(scale(.x))))
# Run PCA (center = FALSE, scale. = FALSE since you've already scaled)
habitat_pca <- prcomp(habitat %>%
dplyr::select(broadleaf, grassland, coniferous, mixed, shrub),
center = FALSE, scale. = FALSE)
View(habitat_pca)
# Inspect PCA results
summary(habitat_pca)
# Loadings (how variables contribute to PCs)
habitat_pca$rotation
# PCA scores for each site
head(habitat_pca$x)
# Combine PCA scores back with site info
habitat_pca_df <- bind_cols(
habitat %>% dplyr::select(array, site),
as.data.frame(habitat_pca$x)
)
View(habitat)
View(habitat_pca_df)
ggplot(habitat_pca_df, aes(x = PC1, y = PC2, color = array)) +
geom_point(size = 3) +
theme_minimal() +
labs(title = "PCA of Habitat Variables",
x = "PC1", y = "PC2")
#Can I do a PCA of the habitat variables?
library(factoextra)
install.packages("factoextra")
library(rgl)
install.packages("rgl")
fviz_pca_biplot(habitat_pca,
axes = c(1, 2, 3),     # use first 3 PCs
label = "var",         # show variable loadings
habillage = habitat$array,  # color by array
addEllipses = TRUE,
repel = TRUE,
geom.ind = "point") +
ggtitle("3D PCA Biplot of Habitat Variables")
#Can I do a PCA of the habitat variables?
library(factoextra)
library(rgl)
fviz_pca_biplot(habitat_pca,
axes = c(1, 2, 3),     # use first 3 PCs
label = "var",         # show variable loadings
habillage = habitat$array,  # color by array
addEllipses = TRUE,
repel = TRUE,
geom.ind = "point") +
ggtitle("3D PCA Biplot of Habitat Variables")
fviz_pca_biplot(habitat_pca,
axes = c(1, 2, ),     # use first 3 PCs
label = "var",         # show variable loadings
habillage = habitat$array,  # color by array
addEllipses = TRUE,
repel = TRUE,
geom.ind = "point") +
ggtitle("3D PCA Biplot of Habitat Variables")
fviz_pca_biplot(habitat_pca,
axes = c(1, 2),     # use first 3 PCs
label = "var",         # show variable loadings
habillage = habitat$array,  # color by array
addEllipses = TRUE,
repel = TRUE,
geom.ind = "point") +
ggtitle("3D PCA Biplot of Habitat Variables")
